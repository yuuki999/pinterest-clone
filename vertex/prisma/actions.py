# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE name = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
                'birthdate': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'birthdate': datetime.datetime.utcnow(),
                },
                {
                    # data to create a User record
                    'birthdate': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'id': 'ggciceaie',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'id': 'bbehjachib',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'id': 'cadfabfehe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the email field
        users = await User.prisma().find_many(
            take=5,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the emailVerified field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'emailVerified': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the image field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'image': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'id': 'dgiiaaijj',
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'id': 'bfaiacjjfc',
            },
            data={
                'create': {
                    'id': 'bfaiacjjfc',
                    'birthdate': datetime.datetime.utcnow(),
                },
                'update': {
                    'birthdate': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'hashedPassword': 'eigcfgbif'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'birthdate': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeys'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by updatedAt values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AccountActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Account]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Account.prisma().query_raw(
            'SELECT * FROM Account WHERE id = $1',
            'bagcfbhiig',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Account
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Account.prisma().query_first(
            'SELECT * FROM Account WHERE userId = $1',
            'cghideieh',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AccountCreateInput,
        include: Optional[types.AccountInclude] = None
    ) -> _PrismaModelT:
        """Create a new Account record.

        Parameters
        ----------
        data
            Account record data
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The created Account record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Account record from just the required fields
        account = await Account.prisma().create(
            data={
                # data to create a Account record
                'userId': 'biabhbdai',
                'type': 'idghgaicb',
                'provider': 'fjfddhigg',
                'providerAccountId': 'hjaecfifb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AccountCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Account records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Account record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Account.prisma().create_many(
            data=[
                {
                    # data to create a Account record
                    'userId': 'cbbbjbfcii',
                    'type': 'bbejhfidcb',
                    'provider': 'bgeecijdgg',
                    'providerAccountId': 'bdiicjafbj',
                },
                {
                    # data to create a Account record
                    'userId': 'bgehebiafc',
                    'type': 'bghffegacj',
                    'provider': 'bhghchehcc',
                    'providerAccountId': 'dcgchcbbf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AccountWhereUniqueInput,
        include: Optional[types.AccountInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Account record.

        Parameters
        ----------
        where
            Account filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The deleted Account record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        account = await Account.prisma().delete(
            where={
                'id': 'bdedcabahc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AccountWhereUniqueInput,
        include: Optional[types.AccountInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Account record.

        Parameters
        ----------
        where
            Account filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The found Account record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        account = await Account.prisma().find_unique(
            where={
                'id': 'ghfhiafcb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AccountWhereUniqueInput,
        include: Optional[types.AccountInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Account record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Account filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The found Account record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        account = await Account.prisma().find_unique_or_raise(
            where={
                'id': 'heejgedji',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
        include: Optional[types.AccountInclude] = None,
        order: Optional[Union[types.AccountOrderByInput, List[types.AccountOrderByInput]]] = None,
        distinct: Optional[List[types.AccountScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Account records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Account records returned
        skip
            Ignore the first N results
        where
            Account filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Account model
        order
            Order the returned Account records by any field
        distinct
            Filter Account records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Account]
            The list of all Account records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Account records
        accounts = await Account.prisma().find_many(take=10)

        # find the first 5 Account records ordered by the type field
        accounts = await Account.prisma().find_many(
            take=5,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
        include: Optional[types.AccountInclude] = None,
        order: Optional[Union[types.AccountOrderByInput, List[types.AccountOrderByInput]]] = None,
        distinct: Optional[List[types.AccountScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Account record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Account filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Account model
        order
            Order the returned Account records by any field
        distinct
            Filter Account records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Account
            The first Account record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Account record ordered by the provider field
        account = await Account.prisma().find_first(
            skip=1,
            order={
                'provider': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
        include: Optional[types.AccountInclude] = None,
        order: Optional[Union[types.AccountOrderByInput, List[types.AccountOrderByInput]]] = None,
        distinct: Optional[List[types.AccountScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Account record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Account filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Account model
        order
            Order the returned Account records by any field
        distinct
            Filter Account records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Account
            The first Account record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Account record ordered by the providerAccountId field
        account = await Account.prisma().find_first_or_raise(
            skip=1,
            order={
                'providerAccountId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AccountUpdateInput,
        where: types.AccountWhereUniqueInput,
        include: Optional[types.AccountInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Account record.

        Parameters
        ----------
        data
            Account record data specifying what to update
        where
            Account filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The updated Account record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        account = await Account.prisma().update(
            where={
                'id': 'bjgjgibgbf',
            },
            data={
                # data to update the Account record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AccountWhereUniqueInput,
        data: types.AccountUpsertInput,
        include: Optional[types.AccountInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Account filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The created or updated Account record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        account = await Account.prisma().upsert(
            where={
                'id': 'bbbgbhfjge',
            },
            data={
                'create': {
                    'id': 'bbbgbhfjge',
                    'userId': 'bgehebiafc',
                    'type': 'bghffegacj',
                    'provider': 'bhghchehcc',
                    'providerAccountId': 'dcgchcbbf',
                },
                'update': {
                    'userId': 'bgehebiafc',
                    'type': 'bghffegacj',
                    'provider': 'bhghchehcc',
                    'providerAccountId': 'dcgchcbbf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AccountUpdateManyMutationInput,
        where: types.AccountWhereInput,
    ) -> int:
        """Update multiple Account records

        Parameters
        ----------
        data
            Account data to update the selected Account records to
        where
            Filter to select the Account records to update

        Returns
        -------
        int
            The total number of Account records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Account records
        total = await Account.prisma().update_many(
            data={
                'refresh_token': 'igbehcbab'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Account records present in the database

        Parameters
        ----------
        select
            Select the Account fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Account filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AccountCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Account.prisma().count()

        # results: prisma.types.AccountCountAggregateOutput
        results = await Account.prisma().count(
            select={
                '_all': True,
                'access_token': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AccountCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
    ) -> types.AccountCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AccountCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
    ) -> Union[int, types.AccountCountAggregateOutput]:
        """Count the number of Account records present in the database

        Parameters
        ----------
        select
            Select the Account fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Account filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AccountCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Account.prisma().count()

        # results: prisma.types.AccountCountAggregateOutput
        results = await Account.prisma().count(
            select={
                '_all': True,
                'expires_at': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AccountCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AccountWhereInput] = None
    ) -> int:
        """Delete multiple Account records.

        Parameters
        ----------
        where
            Optional Account filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Account records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Account records
        total = await Account.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AccountScalarFieldKeys'],
        *,
        where: Optional['types.AccountWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AccountAvgAggregateInput'] = None,
        sum: Optional['types.AccountSumAggregateInput'] = None,
        min: Optional['types.AccountMinAggregateInput'] = None,
        max: Optional['types.AccountMaxAggregateInput'] = None,
        having: Optional['types.AccountScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AccountCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AccountScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AccountScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AccountGroupByOutput']:
        """Group Account records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Account fields to group records by
        where
            Account filter to select records
        take
            Limit the maximum number of Account records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AccountGroupByOutput]
            A list of dictionaries representing the Account record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Account records by token_type values
        # and count how many records are in each group
        results = await Account.prisma().group_by(
            ['token_type'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SessionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Session]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Session.prisma().query_raw(
            'SELECT * FROM Session WHERE id = $1',
            'bdadaadhag',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Session
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Session.prisma().query_first(
            'SELECT * FROM Session WHERE sessionToken = $1',
            'bgiggdidbf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SessionCreateInput,
        include: Optional[types.SessionInclude] = None
    ) -> _PrismaModelT:
        """Create a new Session record.

        Parameters
        ----------
        data
            Session record data
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The created Session record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Session record from just the required fields
        session = await Session.prisma().create(
            data={
                # data to create a Session record
                'sessionToken': 'caaaedabfc',
                'userId': 'bigibebcib',
                'expires': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SessionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Session records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Session record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Session.prisma().create_many(
            data=[
                {
                    # data to create a Session record
                    'sessionToken': 'bigaiehgcc',
                    'userId': 'beeifcbebf',
                    'expires': datetime.datetime.utcnow(),
                },
                {
                    # data to create a Session record
                    'sessionToken': 'bgcigfahea',
                    'userId': 'bcejgaggif',
                    'expires': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Session record.

        Parameters
        ----------
        where
            Session filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The deleted Session record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = await Session.prisma().delete(
            where={
                'id': 'idfjadbcc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Session record.

        Parameters
        ----------
        where
            Session filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The found Session record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = await Session.prisma().find_unique(
            where={
                'id': 'hgdhbjhhj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Session record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Session filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The found Session record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = await Session.prisma().find_unique_or_raise(
            where={
                'id': 'ecjjjfbae',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
        include: Optional[types.SessionInclude] = None,
        order: Optional[Union[types.SessionOrderByInput, List[types.SessionOrderByInput]]] = None,
        distinct: Optional[List[types.SessionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Session records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Session records returned
        skip
            Ignore the first N results
        where
            Session filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Session model
        order
            Order the returned Session records by any field
        distinct
            Filter Session records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Session]
            The list of all Session records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Session records
        sessions = await Session.prisma().find_many(take=10)

        # find the first 5 Session records ordered by the userId field
        sessions = await Session.prisma().find_many(
            take=5,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
        include: Optional[types.SessionInclude] = None,
        order: Optional[Union[types.SessionOrderByInput, List[types.SessionOrderByInput]]] = None,
        distinct: Optional[List[types.SessionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Session record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Session filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Session model
        order
            Order the returned Session records by any field
        distinct
            Filter Session records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Session
            The first Session record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Session record ordered by the expires field
        session = await Session.prisma().find_first(
            skip=1,
            order={
                'expires': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
        include: Optional[types.SessionInclude] = None,
        order: Optional[Union[types.SessionOrderByInput, List[types.SessionOrderByInput]]] = None,
        distinct: Optional[List[types.SessionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Session record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Session filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Session model
        order
            Order the returned Session records by any field
        distinct
            Filter Session records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Session
            The first Session record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Session record ordered by the id field
        session = await Session.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SessionUpdateInput,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Session record.

        Parameters
        ----------
        data
            Session record data specifying what to update
        where
            Session filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The updated Session record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        session = await Session.prisma().update(
            where={
                'id': 'bhhfibbigf',
            },
            data={
                # data to update the Session record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SessionWhereUniqueInput,
        data: types.SessionUpsertInput,
        include: Optional[types.SessionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Session filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The created or updated Session record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = await Session.prisma().upsert(
            where={
                'id': 'ijdbeffgg',
            },
            data={
                'create': {
                    'id': 'ijdbeffgg',
                    'sessionToken': 'bgcigfahea',
                    'userId': 'bcejgaggif',
                    'expires': datetime.datetime.utcnow(),
                },
                'update': {
                    'sessionToken': 'bgcigfahea',
                    'userId': 'bcejgaggif',
                    'expires': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SessionUpdateManyMutationInput,
        where: types.SessionWhereInput,
    ) -> int:
        """Update multiple Session records

        Parameters
        ----------
        data
            Session data to update the selected Session records to
        where
            Filter to select the Session records to update

        Returns
        -------
        int
            The total number of Session records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Session records
        total = await Session.prisma().update_many(
            data={
                'sessionToken': 'jjfeafhfj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Session records present in the database

        Parameters
        ----------
        select
            Select the Session fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Session filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SessionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Session.prisma().count()

        # results: prisma.types.SessionCountAggregateOutput
        results = await Session.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SessionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
    ) -> types.SessionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SessionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
    ) -> Union[int, types.SessionCountAggregateOutput]:
        """Count the number of Session records present in the database

        Parameters
        ----------
        select
            Select the Session fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Session filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SessionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Session.prisma().count()

        # results: prisma.types.SessionCountAggregateOutput
        results = await Session.prisma().count(
            select={
                '_all': True,
                'expires': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SessionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SessionWhereInput] = None
    ) -> int:
        """Delete multiple Session records.

        Parameters
        ----------
        where
            Optional Session filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Session records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Session records
        total = await Session.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SessionScalarFieldKeys'],
        *,
        where: Optional['types.SessionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SessionAvgAggregateInput'] = None,
        sum: Optional['types.SessionSumAggregateInput'] = None,
        min: Optional['types.SessionMinAggregateInput'] = None,
        max: Optional['types.SessionMaxAggregateInput'] = None,
        having: Optional['types.SessionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SessionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SessionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.SessionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.SessionGroupByOutput']:
        """Group Session records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Session fields to group records by
        where
            Session filter to select records
        take
            Limit the maximum number of Session records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SessionGroupByOutput]
            A list of dictionaries representing the Session record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Session records by id values
        # and count how many records are in each group
        results = await Session.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class BoardActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Board]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Board.prisma().query_raw(
            'SELECT * FROM Board WHERE id = $1',
            'cbachdgfce',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Board
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Board.prisma().query_first(
            'SELECT * FROM Board WHERE title = $1',
            'chbfcacbd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.BoardCreateInput,
        include: Optional[types.BoardInclude] = None
    ) -> _PrismaModelT:
        """Create a new Board record.

        Parameters
        ----------
        data
            Board record data
        include
            Specifies which relations should be loaded on the returned Board model

        Returns
        -------
        prisma.models.Board
            The created Board record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Board record from just the required fields
        board = await Board.prisma().create(
            data={
                # data to create a Board record
                'title': 'efggddide',
                'userId': 'caficfigfb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.BoardCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Board records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Board record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Board.prisma().create_many(
            data=[
                {
                    # data to create a Board record
                    'title': 'bfidgijfjc',
                    'userId': 'ihieecagf',
                },
                {
                    # data to create a Board record
                    'title': 'bghfciaafe',
                    'userId': 'bgchfhgceh',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.BoardWhereUniqueInput,
        include: Optional[types.BoardInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Board record.

        Parameters
        ----------
        where
            Board filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Board model

        Returns
        -------
        prisma.models.Board
            The deleted Board record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        board = await Board.prisma().delete(
            where={
                'id': 'cafeiaccbc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.BoardWhereUniqueInput,
        include: Optional[types.BoardInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Board record.

        Parameters
        ----------
        where
            Board filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Board model

        Returns
        -------
        prisma.models.Board
            The found Board record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        board = await Board.prisma().find_unique(
            where={
                'id': 'gaddfhfh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.BoardWhereUniqueInput,
        include: Optional[types.BoardInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Board record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Board filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Board model

        Returns
        -------
        prisma.models.Board
            The found Board record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        board = await Board.prisma().find_unique_or_raise(
            where={
                'id': 'gieegcbeg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BoardWhereInput] = None,
        cursor: Optional[types.BoardWhereUniqueInput] = None,
        include: Optional[types.BoardInclude] = None,
        order: Optional[Union[types.BoardOrderByInput, List[types.BoardOrderByInput]]] = None,
        distinct: Optional[List[types.BoardScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Board records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Board records returned
        skip
            Ignore the first N results
        where
            Board filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Board model
        order
            Order the returned Board records by any field
        distinct
            Filter Board records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Board]
            The list of all Board records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Board records
        boards = await Board.prisma().find_many(take=10)

        # find the first 5 Board records ordered by the description field
        boards = await Board.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BoardWhereInput] = None,
        cursor: Optional[types.BoardWhereUniqueInput] = None,
        include: Optional[types.BoardInclude] = None,
        order: Optional[Union[types.BoardOrderByInput, List[types.BoardOrderByInput]]] = None,
        distinct: Optional[List[types.BoardScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Board record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Board filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Board model
        order
            Order the returned Board records by any field
        distinct
            Filter Board records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Board
            The first Board record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Board record ordered by the isPrivate field
        board = await Board.prisma().find_first(
            skip=1,
            order={
                'isPrivate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BoardWhereInput] = None,
        cursor: Optional[types.BoardWhereUniqueInput] = None,
        include: Optional[types.BoardInclude] = None,
        order: Optional[Union[types.BoardOrderByInput, List[types.BoardOrderByInput]]] = None,
        distinct: Optional[List[types.BoardScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Board record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Board filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Board model
        order
            Order the returned Board records by any field
        distinct
            Filter Board records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Board
            The first Board record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Board record ordered by the userId field
        board = await Board.prisma().find_first_or_raise(
            skip=1,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.BoardUpdateInput,
        where: types.BoardWhereUniqueInput,
        include: Optional[types.BoardInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Board record.

        Parameters
        ----------
        data
            Board record data specifying what to update
        where
            Board filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Board model

        Returns
        -------
        prisma.models.Board
            The updated Board record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        board = await Board.prisma().update(
            where={
                'id': 'bgcffadich',
            },
            data={
                # data to update the Board record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.BoardWhereUniqueInput,
        data: types.BoardUpsertInput,
        include: Optional[types.BoardInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Board filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Board model

        Returns
        -------
        prisma.models.Board
            The created or updated Board record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        board = await Board.prisma().upsert(
            where={
                'id': 'fcbichhci',
            },
            data={
                'create': {
                    'id': 'fcbichhci',
                    'title': 'bghfciaafe',
                    'userId': 'bgchfhgceh',
                },
                'update': {
                    'title': 'bghfciaafe',
                    'userId': 'bgchfhgceh',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.BoardUpdateManyMutationInput,
        where: types.BoardWhereInput,
    ) -> int:
        """Update multiple Board records

        Parameters
        ----------
        data
            Board data to update the selected Board records to
        where
            Filter to select the Board records to update

        Returns
        -------
        int
            The total number of Board records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Board records
        total = await Board.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BoardWhereInput] = None,
        cursor: Optional[types.BoardWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Board records present in the database

        Parameters
        ----------
        select
            Select the Board fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Board filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BoardCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Board.prisma().count()

        # results: prisma.types.BoardCountAggregateOutput
        results = await Board.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.BoardCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BoardWhereInput] = None,
        cursor: Optional[types.BoardWhereUniqueInput] = None,
    ) -> types.BoardCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.BoardCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BoardWhereInput] = None,
        cursor: Optional[types.BoardWhereUniqueInput] = None,
    ) -> Union[int, types.BoardCountAggregateOutput]:
        """Count the number of Board records present in the database

        Parameters
        ----------
        select
            Select the Board fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Board filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BoardCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Board.prisma().count()

        # results: prisma.types.BoardCountAggregateOutput
        results = await Board.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.BoardCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.BoardWhereInput] = None
    ) -> int:
        """Delete multiple Board records.

        Parameters
        ----------
        where
            Optional Board filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Board records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Board records
        total = await Board.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.BoardScalarFieldKeys'],
        *,
        where: Optional['types.BoardWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.BoardAvgAggregateInput'] = None,
        sum: Optional['types.BoardSumAggregateInput'] = None,
        min: Optional['types.BoardMinAggregateInput'] = None,
        max: Optional['types.BoardMaxAggregateInput'] = None,
        having: Optional['types.BoardScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.BoardCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.BoardScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.BoardScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.BoardGroupByOutput']:
        """Group Board records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Board fields to group records by
        where
            Board filter to select records
        take
            Limit the maximum number of Board records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.BoardGroupByOutput]
            A list of dictionaries representing the Board record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Board records by title values
        # and count how many records are in each group
        results = await Board.prisma().group_by(
            ['title'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PinActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Pin]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Pin.prisma().query_raw(
            'SELECT * FROM Pin WHERE id = $1',
            'bcggadccgf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Pin
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Pin.prisma().query_first(
            'SELECT * FROM Pin WHERE title = $1',
            'jdcfdcgc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PinCreateInput,
        include: Optional[types.PinInclude] = None
    ) -> _PrismaModelT:
        """Create a new Pin record.

        Parameters
        ----------
        data
            Pin record data
        include
            Specifies which relations should be loaded on the returned Pin model

        Returns
        -------
        prisma.models.Pin
            The created Pin record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Pin record from just the required fields
        pin = await Pin.prisma().create(
            data={
                # data to create a Pin record
                'title': 'cafdaehjid',
                'imageUrl': 'gifdddbia',
                'userId': 'bchehecef',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PinCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Pin records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Pin record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Pin.prisma().create_many(
            data=[
                {
                    # data to create a Pin record
                    'title': 'jeijcbhfe',
                    'imageUrl': 'bjgejjabff',
                    'userId': 'bcciijbibg',
                },
                {
                    # data to create a Pin record
                    'title': 'cffcachfd',
                    'imageUrl': 'bccdfhdigc',
                    'userId': 'febcgjbfj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PinWhereUniqueInput,
        include: Optional[types.PinInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Pin record.

        Parameters
        ----------
        where
            Pin filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Pin model

        Returns
        -------
        prisma.models.Pin
            The deleted Pin record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        pin = await Pin.prisma().delete(
            where={
                'id': 'bageiegghg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PinWhereUniqueInput,
        include: Optional[types.PinInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Pin record.

        Parameters
        ----------
        where
            Pin filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Pin model

        Returns
        -------
        prisma.models.Pin
            The found Pin record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        pin = await Pin.prisma().find_unique(
            where={
                'id': 'faidicegb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PinWhereUniqueInput,
        include: Optional[types.PinInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Pin record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Pin filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Pin model

        Returns
        -------
        prisma.models.Pin
            The found Pin record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        pin = await Pin.prisma().find_unique_or_raise(
            where={
                'id': 'bacecgfhbe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PinWhereInput] = None,
        cursor: Optional[types.PinWhereUniqueInput] = None,
        include: Optional[types.PinInclude] = None,
        order: Optional[Union[types.PinOrderByInput, List[types.PinOrderByInput]]] = None,
        distinct: Optional[List[types.PinScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Pin records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Pin records returned
        skip
            Ignore the first N results
        where
            Pin filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Pin model
        order
            Order the returned Pin records by any field
        distinct
            Filter Pin records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Pin]
            The list of all Pin records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Pin records
        pins = await Pin.prisma().find_many(take=10)

        # find the first 5 Pin records ordered by the description field
        pins = await Pin.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PinWhereInput] = None,
        cursor: Optional[types.PinWhereUniqueInput] = None,
        include: Optional[types.PinInclude] = None,
        order: Optional[Union[types.PinOrderByInput, List[types.PinOrderByInput]]] = None,
        distinct: Optional[List[types.PinScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Pin record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Pin filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Pin model
        order
            Order the returned Pin records by any field
        distinct
            Filter Pin records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Pin
            The first Pin record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Pin record ordered by the imageUrl field
        pin = await Pin.prisma().find_first(
            skip=1,
            order={
                'imageUrl': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PinWhereInput] = None,
        cursor: Optional[types.PinWhereUniqueInput] = None,
        include: Optional[types.PinInclude] = None,
        order: Optional[Union[types.PinOrderByInput, List[types.PinOrderByInput]]] = None,
        distinct: Optional[List[types.PinScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Pin record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Pin filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Pin model
        order
            Order the returned Pin records by any field
        distinct
            Filter Pin records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Pin
            The first Pin record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Pin record ordered by the userId field
        pin = await Pin.prisma().find_first_or_raise(
            skip=1,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PinUpdateInput,
        where: types.PinWhereUniqueInput,
        include: Optional[types.PinInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Pin record.

        Parameters
        ----------
        data
            Pin record data specifying what to update
        where
            Pin filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Pin model

        Returns
        -------
        prisma.models.Pin
            The updated Pin record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        pin = await Pin.prisma().update(
            where={
                'id': 'ihcahiead',
            },
            data={
                # data to update the Pin record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PinWhereUniqueInput,
        data: types.PinUpsertInput,
        include: Optional[types.PinInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Pin filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Pin model

        Returns
        -------
        prisma.models.Pin
            The created or updated Pin record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        pin = await Pin.prisma().upsert(
            where={
                'id': 'biheheiajg',
            },
            data={
                'create': {
                    'id': 'biheheiajg',
                    'title': 'cffcachfd',
                    'imageUrl': 'bccdfhdigc',
                    'userId': 'febcgjbfj',
                },
                'update': {
                    'title': 'cffcachfd',
                    'imageUrl': 'bccdfhdigc',
                    'userId': 'febcgjbfj',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PinUpdateManyMutationInput,
        where: types.PinWhereInput,
    ) -> int:
        """Update multiple Pin records

        Parameters
        ----------
        data
            Pin data to update the selected Pin records to
        where
            Filter to select the Pin records to update

        Returns
        -------
        int
            The total number of Pin records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Pin records
        total = await Pin.prisma().update_many(
            data={
                'boardId': 'jbgijghgb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PinWhereInput] = None,
        cursor: Optional[types.PinWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Pin records present in the database

        Parameters
        ----------
        select
            Select the Pin fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Pin filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PinCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Pin.prisma().count()

        # results: prisma.types.PinCountAggregateOutput
        results = await Pin.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PinCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PinWhereInput] = None,
        cursor: Optional[types.PinWhereUniqueInput] = None,
    ) -> types.PinCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PinCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PinWhereInput] = None,
        cursor: Optional[types.PinWhereUniqueInput] = None,
    ) -> Union[int, types.PinCountAggregateOutput]:
        """Count the number of Pin records present in the database

        Parameters
        ----------
        select
            Select the Pin fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Pin filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PinCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Pin.prisma().count()

        # results: prisma.types.PinCountAggregateOutput
        results = await Pin.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PinCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PinWhereInput] = None
    ) -> int:
        """Delete multiple Pin records.

        Parameters
        ----------
        where
            Optional Pin filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Pin records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Pin records
        total = await Pin.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PinScalarFieldKeys'],
        *,
        where: Optional['types.PinWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PinAvgAggregateInput'] = None,
        sum: Optional['types.PinSumAggregateInput'] = None,
        min: Optional['types.PinMinAggregateInput'] = None,
        max: Optional['types.PinMaxAggregateInput'] = None,
        having: Optional['types.PinScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PinCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PinScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.PinScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.PinGroupByOutput']:
        """Group Pin records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Pin fields to group records by
        where
            Pin filter to select records
        take
            Limit the maximum number of Pin records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PinGroupByOutput]
            A list of dictionaries representing the Pin record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Pin records by id values
        # and count how many records are in each group
        results = await Pin.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CommentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Comment]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Comment.prisma().query_raw(
            'SELECT * FROM Comment WHERE id = $1',
            'hgjcghfbi',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Comment
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Comment.prisma().query_first(
            'SELECT * FROM Comment WHERE text = $1',
            'icadbcehj',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CommentCreateInput,
        include: Optional[types.CommentInclude] = None
    ) -> _PrismaModelT:
        """Create a new Comment record.

        Parameters
        ----------
        data
            Comment record data
        include
            Specifies which relations should be loaded on the returned Comment model

        Returns
        -------
        prisma.models.Comment
            The created Comment record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Comment record from just the required fields
        comment = await Comment.prisma().create(
            data={
                # data to create a Comment record
                'text': 'jchciaee',
                'pinId': 'deeificjd',
                'userId': 'bbcbhebbda',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CommentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Comment records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Comment record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Comment.prisma().create_many(
            data=[
                {
                    # data to create a Comment record
                    'text': 'bejfijgcfb',
                    'pinId': 'caifcbgii',
                    'userId': 'igaibbfgj',
                },
                {
                    # data to create a Comment record
                    'text': 'bggajdcbbi',
                    'pinId': 'fcfhgbjed',
                    'userId': 'hdgcajhjg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CommentWhereUniqueInput,
        include: Optional[types.CommentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Comment record.

        Parameters
        ----------
        where
            Comment filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Comment model

        Returns
        -------
        prisma.models.Comment
            The deleted Comment record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        comment = await Comment.prisma().delete(
            where={
                'id': 'ejdjahicb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CommentWhereUniqueInput,
        include: Optional[types.CommentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Comment record.

        Parameters
        ----------
        where
            Comment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Comment model

        Returns
        -------
        prisma.models.Comment
            The found Comment record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        comment = await Comment.prisma().find_unique(
            where={
                'id': 'gdjgigfgc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CommentWhereUniqueInput,
        include: Optional[types.CommentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Comment record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Comment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Comment model

        Returns
        -------
        prisma.models.Comment
            The found Comment record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        comment = await Comment.prisma().find_unique_or_raise(
            where={
                'id': 'gfeaahdeh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommentWhereInput] = None,
        cursor: Optional[types.CommentWhereUniqueInput] = None,
        include: Optional[types.CommentInclude] = None,
        order: Optional[Union[types.CommentOrderByInput, List[types.CommentOrderByInput]]] = None,
        distinct: Optional[List[types.CommentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Comment records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Comment records returned
        skip
            Ignore the first N results
        where
            Comment filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Comment model
        order
            Order the returned Comment records by any field
        distinct
            Filter Comment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Comment]
            The list of all Comment records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Comment records
        comments = await Comment.prisma().find_many(take=10)

        # find the first 5 Comment records ordered by the pinId field
        comments = await Comment.prisma().find_many(
            take=5,
            order={
                'pinId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CommentWhereInput] = None,
        cursor: Optional[types.CommentWhereUniqueInput] = None,
        include: Optional[types.CommentInclude] = None,
        order: Optional[Union[types.CommentOrderByInput, List[types.CommentOrderByInput]]] = None,
        distinct: Optional[List[types.CommentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Comment record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Comment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Comment model
        order
            Order the returned Comment records by any field
        distinct
            Filter Comment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Comment
            The first Comment record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Comment record ordered by the userId field
        comment = await Comment.prisma().find_first(
            skip=1,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CommentWhereInput] = None,
        cursor: Optional[types.CommentWhereUniqueInput] = None,
        include: Optional[types.CommentInclude] = None,
        order: Optional[Union[types.CommentOrderByInput, List[types.CommentOrderByInput]]] = None,
        distinct: Optional[List[types.CommentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Comment record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Comment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Comment model
        order
            Order the returned Comment records by any field
        distinct
            Filter Comment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Comment
            The first Comment record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Comment record ordered by the createdAt field
        comment = await Comment.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CommentUpdateInput,
        where: types.CommentWhereUniqueInput,
        include: Optional[types.CommentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Comment record.

        Parameters
        ----------
        data
            Comment record data specifying what to update
        where
            Comment filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Comment model

        Returns
        -------
        prisma.models.Comment
            The updated Comment record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        comment = await Comment.prisma().update(
            where={
                'id': 'bjafcgbffc',
            },
            data={
                # data to update the Comment record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CommentWhereUniqueInput,
        data: types.CommentUpsertInput,
        include: Optional[types.CommentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Comment filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Comment model

        Returns
        -------
        prisma.models.Comment
            The created or updated Comment record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        comment = await Comment.prisma().upsert(
            where={
                'id': 'hihegjif',
            },
            data={
                'create': {
                    'id': 'hihegjif',
                    'text': 'bggajdcbbi',
                    'pinId': 'fcfhgbjed',
                    'userId': 'hdgcajhjg',
                },
                'update': {
                    'text': 'bggajdcbbi',
                    'pinId': 'fcfhgbjed',
                    'userId': 'hdgcajhjg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CommentUpdateManyMutationInput,
        where: types.CommentWhereInput,
    ) -> int:
        """Update multiple Comment records

        Parameters
        ----------
        data
            Comment data to update the selected Comment records to
        where
            Filter to select the Comment records to update

        Returns
        -------
        int
            The total number of Comment records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Comment records
        total = await Comment.prisma().update_many(
            data={
                'updatedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommentWhereInput] = None,
        cursor: Optional[types.CommentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Comment records present in the database

        Parameters
        ----------
        select
            Select the Comment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Comment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CommentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Comment.prisma().count()

        # results: prisma.types.CommentCountAggregateOutput
        results = await Comment.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CommentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommentWhereInput] = None,
        cursor: Optional[types.CommentWhereUniqueInput] = None,
    ) -> types.CommentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CommentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommentWhereInput] = None,
        cursor: Optional[types.CommentWhereUniqueInput] = None,
    ) -> Union[int, types.CommentCountAggregateOutput]:
        """Count the number of Comment records present in the database

        Parameters
        ----------
        select
            Select the Comment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Comment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CommentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Comment.prisma().count()

        # results: prisma.types.CommentCountAggregateOutput
        results = await Comment.prisma().count(
            select={
                '_all': True,
                'text': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CommentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CommentWhereInput] = None
    ) -> int:
        """Delete multiple Comment records.

        Parameters
        ----------
        where
            Optional Comment filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Comment records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Comment records
        total = await Comment.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CommentScalarFieldKeys'],
        *,
        where: Optional['types.CommentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CommentAvgAggregateInput'] = None,
        sum: Optional['types.CommentSumAggregateInput'] = None,
        min: Optional['types.CommentMinAggregateInput'] = None,
        max: Optional['types.CommentMaxAggregateInput'] = None,
        having: Optional['types.CommentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CommentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CommentScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CommentScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CommentGroupByOutput']:
        """Group Comment records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Comment fields to group records by
        where
            Comment filter to select records
        take
            Limit the maximum number of Comment records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CommentGroupByOutput]
            A list of dictionaries representing the Comment record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Comment records by pinId values
        # and count how many records are in each group
        results = await Comment.prisma().group_by(
            ['pinId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LikeActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Like]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Like.prisma().query_raw(
            'SELECT * FROM Like WHERE id = $1',
            'bdjidcidac',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Like
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Like.prisma().query_first(
            'SELECT * FROM Like WHERE userId = $1',
            'ifgaaagff',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LikeCreateInput,
        include: Optional[types.LikeInclude] = None
    ) -> _PrismaModelT:
        """Create a new Like record.

        Parameters
        ----------
        data
            Like record data
        include
            Specifies which relations should be loaded on the returned Like model

        Returns
        -------
        prisma.models.Like
            The created Like record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Like record from just the required fields
        like = await Like.prisma().create(
            data={
                # data to create a Like record
                'userId': 'befcddgjce',
                'pinId': 'bfhdbjjgfd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LikeCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Like records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Like record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Like.prisma().create_many(
            data=[
                {
                    # data to create a Like record
                    'userId': 'cabdjadaji',
                    'pinId': 'faajgfadf',
                },
                {
                    # data to create a Like record
                    'userId': 'biaagcedjc',
                    'pinId': 'cahhaghecf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LikeWhereUniqueInput,
        include: Optional[types.LikeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Like record.

        Parameters
        ----------
        where
            Like filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Like model

        Returns
        -------
        prisma.models.Like
            The deleted Like record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        like = await Like.prisma().delete(
            where={
                'id': 'bghcbbcidi',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LikeWhereUniqueInput,
        include: Optional[types.LikeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Like record.

        Parameters
        ----------
        where
            Like filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Like model

        Returns
        -------
        prisma.models.Like
            The found Like record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        like = await Like.prisma().find_unique(
            where={
                'id': 'jcgghhgdj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LikeWhereUniqueInput,
        include: Optional[types.LikeInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Like record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Like filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Like model

        Returns
        -------
        prisma.models.Like
            The found Like record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        like = await Like.prisma().find_unique_or_raise(
            where={
                'id': 'beehgcebbg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LikeWhereInput] = None,
        cursor: Optional[types.LikeWhereUniqueInput] = None,
        include: Optional[types.LikeInclude] = None,
        order: Optional[Union[types.LikeOrderByInput, List[types.LikeOrderByInput]]] = None,
        distinct: Optional[List[types.LikeScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Like records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Like records returned
        skip
            Ignore the first N results
        where
            Like filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Like model
        order
            Order the returned Like records by any field
        distinct
            Filter Like records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Like]
            The list of all Like records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Like records
        likes = await Like.prisma().find_many(take=10)

        # find the first 5 Like records ordered by the pinId field
        likes = await Like.prisma().find_many(
            take=5,
            order={
                'pinId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LikeWhereInput] = None,
        cursor: Optional[types.LikeWhereUniqueInput] = None,
        include: Optional[types.LikeInclude] = None,
        order: Optional[Union[types.LikeOrderByInput, List[types.LikeOrderByInput]]] = None,
        distinct: Optional[List[types.LikeScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Like record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Like filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Like model
        order
            Order the returned Like records by any field
        distinct
            Filter Like records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Like
            The first Like record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Like record ordered by the createdAt field
        like = await Like.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LikeWhereInput] = None,
        cursor: Optional[types.LikeWhereUniqueInput] = None,
        include: Optional[types.LikeInclude] = None,
        order: Optional[Union[types.LikeOrderByInput, List[types.LikeOrderByInput]]] = None,
        distinct: Optional[List[types.LikeScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Like record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Like filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Like model
        order
            Order the returned Like records by any field
        distinct
            Filter Like records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Like
            The first Like record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Like record ordered by the id field
        like = await Like.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LikeUpdateInput,
        where: types.LikeWhereUniqueInput,
        include: Optional[types.LikeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Like record.

        Parameters
        ----------
        data
            Like record data specifying what to update
        where
            Like filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Like model

        Returns
        -------
        prisma.models.Like
            The updated Like record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        like = await Like.prisma().update(
            where={
                'id': 'bhdiaidiaf',
            },
            data={
                # data to update the Like record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LikeWhereUniqueInput,
        data: types.LikeUpsertInput,
        include: Optional[types.LikeInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Like filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Like model

        Returns
        -------
        prisma.models.Like
            The created or updated Like record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        like = await Like.prisma().upsert(
            where={
                'id': 'deajegcfi',
            },
            data={
                'create': {
                    'id': 'deajegcfi',
                    'userId': 'biaagcedjc',
                    'pinId': 'cahhaghecf',
                },
                'update': {
                    'userId': 'biaagcedjc',
                    'pinId': 'cahhaghecf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LikeUpdateManyMutationInput,
        where: types.LikeWhereInput,
    ) -> int:
        """Update multiple Like records

        Parameters
        ----------
        data
            Like data to update the selected Like records to
        where
            Filter to select the Like records to update

        Returns
        -------
        int
            The total number of Like records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Like records
        total = await Like.prisma().update_many(
            data={
                'userId': 'gabahhhjf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LikeWhereInput] = None,
        cursor: Optional[types.LikeWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Like records present in the database

        Parameters
        ----------
        select
            Select the Like fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Like filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LikeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Like.prisma().count()

        # results: prisma.types.LikeCountAggregateOutput
        results = await Like.prisma().count(
            select={
                '_all': True,
                'pinId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LikeCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LikeWhereInput] = None,
        cursor: Optional[types.LikeWhereUniqueInput] = None,
    ) -> types.LikeCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LikeCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LikeWhereInput] = None,
        cursor: Optional[types.LikeWhereUniqueInput] = None,
    ) -> Union[int, types.LikeCountAggregateOutput]:
        """Count the number of Like records present in the database

        Parameters
        ----------
        select
            Select the Like fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Like filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LikeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Like.prisma().count()

        # results: prisma.types.LikeCountAggregateOutput
        results = await Like.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LikeCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LikeWhereInput] = None
    ) -> int:
        """Delete multiple Like records.

        Parameters
        ----------
        where
            Optional Like filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Like records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Like records
        total = await Like.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LikeScalarFieldKeys'],
        *,
        where: Optional['types.LikeWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LikeAvgAggregateInput'] = None,
        sum: Optional['types.LikeSumAggregateInput'] = None,
        min: Optional['types.LikeMinAggregateInput'] = None,
        max: Optional['types.LikeMaxAggregateInput'] = None,
        having: Optional['types.LikeScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LikeCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LikeScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LikeScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LikeGroupByOutput']:
        """Group Like records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Like fields to group records by
        where
            Like filter to select records
        take
            Limit the maximum number of Like records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LikeGroupByOutput]
            A list of dictionaries representing the Like record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Like records by id values
        # and count how many records are in each group
        results = await Like.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SaveActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Save]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Save.prisma().query_raw(
            'SELECT * FROM Save WHERE id = $1',
            'cjagadcjg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Save
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Save.prisma().query_first(
            'SELECT * FROM Save WHERE userId = $1',
            'bifficggej',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SaveCreateInput,
        include: Optional[types.SaveInclude] = None
    ) -> _PrismaModelT:
        """Create a new Save record.

        Parameters
        ----------
        data
            Save record data
        include
            Specifies which relations should be loaded on the returned Save model

        Returns
        -------
        prisma.models.Save
            The created Save record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Save record from just the required fields
        save = await Save.prisma().create(
            data={
                # data to create a Save record
                'userId': 'bgbbaajbic',
                'pinId': 'eegghdhjb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SaveCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Save records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Save record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Save.prisma().create_many(
            data=[
                {
                    # data to create a Save record
                    'userId': 'daafgidjg',
                    'pinId': 'gdcgcgagj',
                },
                {
                    # data to create a Save record
                    'userId': 'bhceabbgja',
                    'pinId': 'ehabfhegh',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SaveWhereUniqueInput,
        include: Optional[types.SaveInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Save record.

        Parameters
        ----------
        where
            Save filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Save model

        Returns
        -------
        prisma.models.Save
            The deleted Save record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        save = await Save.prisma().delete(
            where={
                'id': 'bcajcajjbc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SaveWhereUniqueInput,
        include: Optional[types.SaveInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Save record.

        Parameters
        ----------
        where
            Save filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Save model

        Returns
        -------
        prisma.models.Save
            The found Save record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        save = await Save.prisma().find_unique(
            where={
                'id': 'bfdgheeegf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SaveWhereUniqueInput,
        include: Optional[types.SaveInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Save record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Save filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Save model

        Returns
        -------
        prisma.models.Save
            The found Save record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        save = await Save.prisma().find_unique_or_raise(
            where={
                'id': 'ececbijji',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SaveWhereInput] = None,
        cursor: Optional[types.SaveWhereUniqueInput] = None,
        include: Optional[types.SaveInclude] = None,
        order: Optional[Union[types.SaveOrderByInput, List[types.SaveOrderByInput]]] = None,
        distinct: Optional[List[types.SaveScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Save records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Save records returned
        skip
            Ignore the first N results
        where
            Save filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Save model
        order
            Order the returned Save records by any field
        distinct
            Filter Save records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Save]
            The list of all Save records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Save records
        saves = await Save.prisma().find_many(take=10)

        # find the first 5 Save records ordered by the pinId field
        saves = await Save.prisma().find_many(
            take=5,
            order={
                'pinId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SaveWhereInput] = None,
        cursor: Optional[types.SaveWhereUniqueInput] = None,
        include: Optional[types.SaveInclude] = None,
        order: Optional[Union[types.SaveOrderByInput, List[types.SaveOrderByInput]]] = None,
        distinct: Optional[List[types.SaveScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Save record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Save filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Save model
        order
            Order the returned Save records by any field
        distinct
            Filter Save records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Save
            The first Save record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Save record ordered by the createdAt field
        save = await Save.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SaveWhereInput] = None,
        cursor: Optional[types.SaveWhereUniqueInput] = None,
        include: Optional[types.SaveInclude] = None,
        order: Optional[Union[types.SaveOrderByInput, List[types.SaveOrderByInput]]] = None,
        distinct: Optional[List[types.SaveScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Save record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Save filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Save model
        order
            Order the returned Save records by any field
        distinct
            Filter Save records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Save
            The first Save record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Save record ordered by the id field
        save = await Save.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SaveUpdateInput,
        where: types.SaveWhereUniqueInput,
        include: Optional[types.SaveInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Save record.

        Parameters
        ----------
        data
            Save record data specifying what to update
        where
            Save filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Save model

        Returns
        -------
        prisma.models.Save
            The updated Save record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        save = await Save.prisma().update(
            where={
                'id': 'cbcfgdcdhf',
            },
            data={
                # data to update the Save record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SaveWhereUniqueInput,
        data: types.SaveUpsertInput,
        include: Optional[types.SaveInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Save filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Save model

        Returns
        -------
        prisma.models.Save
            The created or updated Save record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        save = await Save.prisma().upsert(
            where={
                'id': 'fdgjfbhia',
            },
            data={
                'create': {
                    'id': 'fdgjfbhia',
                    'userId': 'bhceabbgja',
                    'pinId': 'ehabfhegh',
                },
                'update': {
                    'userId': 'bhceabbgja',
                    'pinId': 'ehabfhegh',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SaveUpdateManyMutationInput,
        where: types.SaveWhereInput,
    ) -> int:
        """Update multiple Save records

        Parameters
        ----------
        data
            Save data to update the selected Save records to
        where
            Filter to select the Save records to update

        Returns
        -------
        int
            The total number of Save records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Save records
        total = await Save.prisma().update_many(
            data={
                'userId': 'jcehcdchh'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SaveWhereInput] = None,
        cursor: Optional[types.SaveWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Save records present in the database

        Parameters
        ----------
        select
            Select the Save fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Save filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SaveCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Save.prisma().count()

        # results: prisma.types.SaveCountAggregateOutput
        results = await Save.prisma().count(
            select={
                '_all': True,
                'pinId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SaveCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SaveWhereInput] = None,
        cursor: Optional[types.SaveWhereUniqueInput] = None,
    ) -> types.SaveCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SaveCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SaveWhereInput] = None,
        cursor: Optional[types.SaveWhereUniqueInput] = None,
    ) -> Union[int, types.SaveCountAggregateOutput]:
        """Count the number of Save records present in the database

        Parameters
        ----------
        select
            Select the Save fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Save filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SaveCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Save.prisma().count()

        # results: prisma.types.SaveCountAggregateOutput
        results = await Save.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SaveCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SaveWhereInput] = None
    ) -> int:
        """Delete multiple Save records.

        Parameters
        ----------
        where
            Optional Save filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Save records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Save records
        total = await Save.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SaveScalarFieldKeys'],
        *,
        where: Optional['types.SaveWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SaveAvgAggregateInput'] = None,
        sum: Optional['types.SaveSumAggregateInput'] = None,
        min: Optional['types.SaveMinAggregateInput'] = None,
        max: Optional['types.SaveMaxAggregateInput'] = None,
        having: Optional['types.SaveScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SaveCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SaveScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.SaveScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.SaveGroupByOutput']:
        """Group Save records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Save fields to group records by
        where
            Save filter to select records
        take
            Limit the maximum number of Save records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SaveGroupByOutput]
            A list of dictionaries representing the Save record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Save records by id values
        # and count how many records are in each group
        results = await Save.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class FollowActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Follow]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Follow.prisma().query_raw(
            'SELECT * FROM Follow WHERE id = $1',
            'bgcbjdhjcc',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Follow
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Follow.prisma().query_first(
            'SELECT * FROM Follow WHERE followerId = $1',
            'bieiidcabj',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.FollowCreateInput,
        include: Optional[types.FollowInclude] = None
    ) -> _PrismaModelT:
        """Create a new Follow record.

        Parameters
        ----------
        data
            Follow record data
        include
            Specifies which relations should be loaded on the returned Follow model

        Returns
        -------
        prisma.models.Follow
            The created Follow record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Follow record from just the required fields
        follow = await Follow.prisma().create(
            data={
                # data to create a Follow record
                'followerId': 'bjcbfcieaa',
                'followingId': 'cbaaechiej',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.FollowCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Follow records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Follow record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Follow.prisma().create_many(
            data=[
                {
                    # data to create a Follow record
                    'followerId': 'iejbeaaeg',
                    'followingId': 'jcibfcbhf',
                },
                {
                    # data to create a Follow record
                    'followerId': 'chdadcaga',
                    'followingId': 'jicieifbh',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.FollowWhereUniqueInput,
        include: Optional[types.FollowInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Follow record.

        Parameters
        ----------
        where
            Follow filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Follow model

        Returns
        -------
        prisma.models.Follow
            The deleted Follow record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        follow = await Follow.prisma().delete(
            where={
                'id': 'fbahdheji',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.FollowWhereUniqueInput,
        include: Optional[types.FollowInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Follow record.

        Parameters
        ----------
        where
            Follow filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Follow model

        Returns
        -------
        prisma.models.Follow
            The found Follow record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        follow = await Follow.prisma().find_unique(
            where={
                'id': 'cbbheiicgh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.FollowWhereUniqueInput,
        include: Optional[types.FollowInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Follow record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Follow filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Follow model

        Returns
        -------
        prisma.models.Follow
            The found Follow record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        follow = await Follow.prisma().find_unique_or_raise(
            where={
                'id': 'beabjeejdg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FollowWhereInput] = None,
        cursor: Optional[types.FollowWhereUniqueInput] = None,
        include: Optional[types.FollowInclude] = None,
        order: Optional[Union[types.FollowOrderByInput, List[types.FollowOrderByInput]]] = None,
        distinct: Optional[List[types.FollowScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Follow records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Follow records returned
        skip
            Ignore the first N results
        where
            Follow filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Follow model
        order
            Order the returned Follow records by any field
        distinct
            Filter Follow records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Follow]
            The list of all Follow records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Follow records
        follows = await Follow.prisma().find_many(take=10)

        # find the first 5 Follow records ordered by the followingId field
        follows = await Follow.prisma().find_many(
            take=5,
            order={
                'followingId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.FollowWhereInput] = None,
        cursor: Optional[types.FollowWhereUniqueInput] = None,
        include: Optional[types.FollowInclude] = None,
        order: Optional[Union[types.FollowOrderByInput, List[types.FollowOrderByInput]]] = None,
        distinct: Optional[List[types.FollowScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Follow record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Follow filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Follow model
        order
            Order the returned Follow records by any field
        distinct
            Filter Follow records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Follow
            The first Follow record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Follow record ordered by the createdAt field
        follow = await Follow.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.FollowWhereInput] = None,
        cursor: Optional[types.FollowWhereUniqueInput] = None,
        include: Optional[types.FollowInclude] = None,
        order: Optional[Union[types.FollowOrderByInput, List[types.FollowOrderByInput]]] = None,
        distinct: Optional[List[types.FollowScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Follow record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Follow filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Follow model
        order
            Order the returned Follow records by any field
        distinct
            Filter Follow records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Follow
            The first Follow record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Follow record ordered by the id field
        follow = await Follow.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.FollowUpdateInput,
        where: types.FollowWhereUniqueInput,
        include: Optional[types.FollowInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Follow record.

        Parameters
        ----------
        data
            Follow record data specifying what to update
        where
            Follow filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Follow model

        Returns
        -------
        prisma.models.Follow
            The updated Follow record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        follow = await Follow.prisma().update(
            where={
                'id': 'bcjhgahffd',
            },
            data={
                # data to update the Follow record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.FollowWhereUniqueInput,
        data: types.FollowUpsertInput,
        include: Optional[types.FollowInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Follow filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Follow model

        Returns
        -------
        prisma.models.Follow
            The created or updated Follow record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        follow = await Follow.prisma().upsert(
            where={
                'id': 'fbjeiiffa',
            },
            data={
                'create': {
                    'id': 'fbjeiiffa',
                    'followerId': 'chdadcaga',
                    'followingId': 'jicieifbh',
                },
                'update': {
                    'followerId': 'chdadcaga',
                    'followingId': 'jicieifbh',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.FollowUpdateManyMutationInput,
        where: types.FollowWhereInput,
    ) -> int:
        """Update multiple Follow records

        Parameters
        ----------
        data
            Follow data to update the selected Follow records to
        where
            Filter to select the Follow records to update

        Returns
        -------
        int
            The total number of Follow records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Follow records
        total = await Follow.prisma().update_many(
            data={
                'followerId': 'jhgidcgbf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FollowWhereInput] = None,
        cursor: Optional[types.FollowWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Follow records present in the database

        Parameters
        ----------
        select
            Select the Follow fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Follow filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.FollowCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Follow.prisma().count()

        # results: prisma.types.FollowCountAggregateOutput
        results = await Follow.prisma().count(
            select={
                '_all': True,
                'followingId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.FollowCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FollowWhereInput] = None,
        cursor: Optional[types.FollowWhereUniqueInput] = None,
    ) -> types.FollowCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.FollowCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FollowWhereInput] = None,
        cursor: Optional[types.FollowWhereUniqueInput] = None,
    ) -> Union[int, types.FollowCountAggregateOutput]:
        """Count the number of Follow records present in the database

        Parameters
        ----------
        select
            Select the Follow fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Follow filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.FollowCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Follow.prisma().count()

        # results: prisma.types.FollowCountAggregateOutput
        results = await Follow.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.FollowCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.FollowWhereInput] = None
    ) -> int:
        """Delete multiple Follow records.

        Parameters
        ----------
        where
            Optional Follow filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Follow records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Follow records
        total = await Follow.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.FollowScalarFieldKeys'],
        *,
        where: Optional['types.FollowWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.FollowAvgAggregateInput'] = None,
        sum: Optional['types.FollowSumAggregateInput'] = None,
        min: Optional['types.FollowMinAggregateInput'] = None,
        max: Optional['types.FollowMaxAggregateInput'] = None,
        having: Optional['types.FollowScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.FollowCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.FollowScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.FollowScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.FollowGroupByOutput']:
        """Group Follow records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Follow fields to group records by
        where
            Follow filter to select records
        take
            Limit the maximum number of Follow records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.FollowGroupByOutput]
            A list of dictionaries representing the Follow record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Follow records by id values
        # and count how many records are in each group
        results = await Follow.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models